{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","categories","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","alert","find","category","id","type","value","onChange","target","getGifs","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","image","key","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"qMAGaA,EAAc,SAAC,GAAiC,IAAhCC,EAA+B,EAA/BA,WAAYC,EAAmB,EAAnBA,cAErC,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAwBA,OACI,oCACI,0BAAMC,SAnBQ,SAACC,GACnBA,EAAEC,iBAE8B,IAA7BJ,EAAWK,OAAOC,OACjBC,MAAM,8BACAV,EAAWW,MAAK,SAACC,GAAD,OAAcA,IAAaT,EAAWK,UAC5DE,MAAM,2BAMNT,EAAc,CAACE,EAAWK,QAAb,mBAAwBR,KACrCI,EAAc,OAOV,2BACIS,GAAG,KACHC,KAAK,OACLC,MAAOZ,EACPa,SA5BU,SAACV,GACvBF,EAAcE,EAAEW,OAAOF,a,uBCTlBG,EAAO,uCAAG,WAAMN,GAAN,uBAAAO,EAAA,6DAEbC,EAFa,iDAEsCC,UAAUT,GAFhD,+DAGEU,MAAMF,GAHR,cAGbG,EAHa,gBAIEA,EAAKC,OAJP,uBAIZC,EAJY,EAIZA,KAEDC,EAAOD,EAAKE,KAAI,SAACC,GAAS,IAAD,EAC3B,MAAO,CACHf,GAAIe,EAAIf,GACRgB,MAAOD,EAAIC,MACXT,IAAG,UAAEQ,EAAIE,cAAN,aAAE,EAAYC,iBAAiBX,QAVvB,kBAeZM,GAfY,4CAAH,sDCEPM,EAAc,SAAC,GAAuB,EAArBnB,GAAsB,IAAlBgB,EAAiB,EAAjBA,MAAOT,EAAU,EAAVA,IAIrC,OACI,yBAAKa,UAAU,0CAAf,IACI,yBAAKC,IAAKd,EAAKe,IAAKN,IACpB,2BAAIA,KCJHO,EAAU,SAAC,GAAgB,IAAfxB,EAAc,EAAdA,SAgBrB,EClBwB,SAAEA,GAC1B,MAA0BV,mBAAS,CAC/BuB,KAAM,GACNY,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAsBA,OAdAC,qBAAU,WAENtB,EAAQN,GACL6B,MAAM,SAACC,GAENH,EAAS,CACLd,KAAMiB,EACNL,SAAS,SAKlB,CAACzB,IAEG0B,EDLwBK,CAAa/B,GAAhCkB,EAAZ,EAAOL,KAAaY,EAApB,EAAoBA,QAIpB,OACK,oCACG,wBAAIJ,UAAU,qCAAqCrB,GAClDyB,GAAW,uBAAGJ,UAAU,oCAAb,WAEZ,yBAAKA,UAAU,aAGPH,EAAOH,KAAI,SAACiB,GAAD,OAAW,kBAAC,EAAD,eAAaC,IAAKD,EAAM/B,IAAQ+B,UEO3DE,EApCM,WAGjB,MAAoC5C,mBAAS,CAAC,kBAA9C,mBAAOF,EAAP,KAAmBC,EAAnB,KAcA,OAAQ,oCACE,4CACA,kBAAC,EAAD,CAAaD,WAAYA,EAAYC,cAAeA,IACpD,6BAOOD,EAAW2B,KAAI,SAACf,GAAD,OAAe,kBAAC,EAAD,CACKiC,IAAKjC,EACLA,SAAUA,S,MC5BlEmC,IAASC,OACL,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.a030c362.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\nexport const AddCategory = ({categories, setCategories}) => {\r\n    \r\n    const [inputValue, setInputValue] = useState(''); //Si dejamos el State sin valor, es undefined, y aunque no truena, se ve el error al cambiar el estado\r\n                                                      //Dejarlo asi no es cambio para el usuario y el estado es definido\r\n    \r\n    const handleInputChange = (e) => {\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    const handleSubmmit = (e) => {\r\n        e.preventDefault();\r\n\r\n        if(inputValue.trim().length === 0) {\r\n            alert('Debe agregar una categoria');\r\n        } else if(categories.find((category) => category === inputValue.trim())){\r\n            alert('La categoria ya existe');\r\n        }else{\r\n            //podemos solo traer en la props al setCategories, y agregar la categoria solo haciendo referencia con\r\n            // una funcion\r\n            //Pero como hago validacion de que ya exista, por eso lo mando traer\r\n            //setCategories((categories) => [...categories, inputValue.trim()])\r\n            setCategories([inputValue.trim(), ...categories])\r\n            setInputValue('');\r\n        }\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <form onSubmit={handleSubmmit}>\r\n                <input \r\n                    id='t1' \r\n                    type='text'\r\n                    value={inputValue}\r\n                    onChange={ handleInputChange }\r\n                />\r\n            </form>\r\n        </>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}\r\n","export const getGifs = async(category) => {\r\n\r\n    const url    = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=eDNgk2mG5wSXFmHo22hDV8xnbAi2NpIy`;\r\n    const resp   = await fetch(url);\r\n    const {data} = await resp.json();\r\n    \r\n    const gifs = data.map((img) => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    })\r\n    //console.log(gifs);\r\n\r\n    return gifs; //El resultado es una promesa que devuelve la coleccion de las imagenes\r\n               \r\n\r\n}","import React from 'react'\r\n\r\nexport const GifGridItem = ( {id, title, url} ) => {\r\n\r\n    //console.log({id, title, url});\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\"> {/*No usar class nada mas, ya que si no , se referira a una clase de javascript, no una de css, usar className*/}\r\n            <img src={url} alt={title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React /*, {useState, useEffect}*/ from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs'\r\nimport { GifGridItem } from './GifGridItem';\r\n//import { getGifs } from '../helpers/getGifs';\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n    // Esta parte se va al hook useFetchGifs\r\n\r\n    /*const [images, setImages] = useState([]);\r\n\r\n    useEffect( () => {\r\n        getGifs({category}).then( setImages ); //con useEffect, solo mando ejecutar el codigo una vez al renderizar la pagina, esto por el segundo argumento\r\n    }, [category]) //como no le mandamos una lista de dependencias, se ejecuta solo una vez\r\n            //setImages no tiene argumento porque etsa implicitamente declarado, por eso ni la funcion de flecha se pone\r\n            // Category se pone en la lista de dependencias, ya ue si cambia, el effect se ejecuta de nuevo*/\r\n\r\n    //Cargo un hook, que tiene un setTimeOut, a los 3.5 segundos, resuelve un callback con una funcion de flecha, seteando el state de loading y la data\r\n\r\n    //Asi sola, esta funcion se cargara de nuevo siempre\r\n    //Se añadió useEffect en el hook, para solo renderizarse de nuevo al cambiar category\r\n    const {data:images, loading} = useFetchGifs(category); //Con los dos puntos (data:images) renombro la constante\r\n\r\n    //console.log(images);\r\n\r\n    return (\r\n        (<>\r\n            <h3 className=\"animate__animated animate__fadeIn\">{category}</h3>\r\n            {loading && <p className=\"animate__animated animate__flash\">Loading</p>}\r\n\r\n            <div className=\"card-grid\">\r\n                {\r\n                    \r\n                    images.map((image) => <GifGridItem key={image.id} {...image} />) /*Con map, recorro el objeto usando funcion de flecha, puedo desestructurar el argumento*/\r\n                                                                                    //Puedo usar el operador spread sin indicar que esos son los elemetos del image, los heredara ya que se llaman igual las props a recibir\r\n                }\r\n                \r\n            </div>\r\n            \r\n        </>)\r\n    )\r\n}\r\n","import {useState, useEffect} from 'react'\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    //Los custom hooks funcionan como si fueran functional components, pueden tener efectos, pueden usar reducers, contextos, etc\r\n    //Es la \"clase\" con la carga pesada, y el inicio es el que queda mas limpio\r\n\r\n    useEffect(() => {\r\n\r\n        getGifs(category)\r\n          .then( (imgs) => {\r\n       \r\n            setState({\r\n                data: imgs,\r\n                loading: false\r\n            })\r\n\r\n          } );\r\n\r\n    }, [category])\r\n\r\n    return state;\r\n}","import React, {useState} from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nconst GifExpertApp = () => {\r\n    \r\n    //const [categories, setCategories] = useState(['One Punch Man', 'One Piece', 'Boruto']);\r\n    const [categories, setCategories] = useState(['One Punch Man']);\r\n\r\n    //Si no uso estados, lo manejo directo del item\r\n    /*const handleAdd = () => { \r\n\r\n        if(document.getElementById('t1').value.trim().length == 0) {\r\n            alert('Debe agregar una categoria');\r\n        } else if(categories.find((category) => category === document.getElementById('t1').value.trim())){\r\n            alert('La categoria ya existe');\r\n        }else{\r\n            setCategories([...categories, document.getElementById('t1').value.trim()])\r\n        }\r\n    };*/\r\n\r\n    return (<>\r\n              <h2>GifExpertApp</h2>\r\n              <AddCategory categories={categories} setCategories={setCategories}/>\r\n              <hr></hr>\r\n              \r\n              {/*<input id='t1' type='text'></input>\r\n              <button onClick={handleAdd}>Agregar</button>*/}\r\n\r\n              {/*<ol> Asi estaba para poner las categorias en */}\r\n                  {  //Para descomponer la lista y mostrar cada elemento\r\n                     categories.map((category) =>  <GifGrid \r\n                                                        key={category}\r\n                                                        category={category}/>)\r\n                  }\r\n              {/*</ol>*/}\r\n\r\n            </>);\r\n}\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp />,\n    document.getElementById('root')\n);"],"sourceRoot":""}